// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package db

import (
	"context"
	"time"

	"github.com/lib/pq"
)

const createGame = `-- name: CreateGame :one
INSERT INTO games (
    author,
    difficulty,
    time_limit
) VALUES (
    $1,
    $2::difficulty_level,
    $3::time_limit
)
RETURNING id
`

type CreateGameParams struct {
	Author  string
	Column2 DifficultyLevel
	Column3 TimeLimit
}

func (q *Queries) CreateGame(ctx context.Context, arg CreateGameParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createGame, arg.Author, arg.Column2, arg.Column3)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createGroup = `-- name: CreateGroup :one
INSERT INTO groups (
    game_id,
    link,
    link_terms
) VALUES (
    $1,
    $2,
    $3
)
RETURNING id
`

type CreateGroupParams struct {
	GameID    int64
	Link      string
	LinkTerms string
}

func (q *Queries) CreateGroup(ctx context.Context, arg CreateGroupParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createGroup, arg.GameID, arg.Link, arg.LinkTerms)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createTilesForGroup = `-- name: CreateTilesForGroup :exec
INSERT INTO tiles (
    group_id,
    title
) VALUES ($1, $2)
`

type CreateTilesForGroupParams struct {
	GroupID int64
	Title   string
}

func (q *Queries) CreateTilesForGroup(ctx context.Context, arg CreateTilesForGroupParams) error {
	_, err := q.db.ExecContext(ctx, createTilesForGroup, arg.GroupID, arg.Title)
	return err
}

const getAllGames = `-- name: GetAllGames :many
SELECT
    id,
    author,
    difficulty,
    created_at
FROM
    games
`

type GetAllGamesRow struct {
	ID         int64
	Author     string
	Difficulty DifficultyLevel
	CreatedAt  time.Time
}

func (q *Queries) GetAllGames(ctx context.Context) ([]GetAllGamesRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllGames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllGamesRow
	for rows.Next() {
		var i GetAllGamesRow
		if err := rows.Scan(
			&i.ID,
			&i.Author,
			&i.Difficulty,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGame = `-- name: GetGame :one
SELECT id, author, difficulty, time_limit, created_at, updated_at FROM games
WHERE id = $1
`

func (q *Queries) GetGame(ctx context.Context, id int64) (Game, error) {
	row := q.db.QueryRowContext(ctx, getGame, id)
	var i Game
	err := row.Scan(
		&i.ID,
		&i.Author,
		&i.Difficulty,
		&i.TimeLimit,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getGroup = `-- name: GetGroup :one
SELECT
    id, game_id, link, link_terms, created_at, updated_at
FROM
    groups
WHERE
    id = $1
`

func (q *Queries) GetGroup(ctx context.Context, id int64) (Group, error) {
	row := q.db.QueryRowContext(ctx, getGroup, id)
	var i Group
	err := row.Scan(
		&i.ID,
		&i.GameID,
		&i.Link,
		&i.LinkTerms,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getGroupsForGame = `-- name: GetGroupsForGame :many
SELECT
    id 
FROM 
    groups
WHERE
    game_id = $1
`

func (q *Queries) GetGroupsForGame(ctx context.Context, gameID int64) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, getGroupsForGame, gameID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTilesByIDs = `-- name: GetTilesByIDs :many
SELECT id, group_id, title, created_at, updated_at FROM tiles
WHERE id = ANY($1::bigint[])
`

func (q *Queries) GetTilesByIDs(ctx context.Context, dollar_1 []int64) ([]Tile, error) {
	rows, err := q.db.QueryContext(ctx, getTilesByIDs, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tile
	for rows.Next() {
		var i Tile
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.Title,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTilesForGroup = `-- name: GetTilesForGroup :many
SELECT
    id,
    title 
FROM 
    tiles 
WHERE
    group_id = $1
`

type GetTilesForGroupRow struct {
	ID    int64
	Title string
}

func (q *Queries) GetTilesForGroup(ctx context.Context, groupID int64) ([]GetTilesForGroupRow, error) {
	rows, err := q.db.QueryContext(ctx, getTilesForGroup, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTilesForGroupRow
	for rows.Next() {
		var i GetTilesForGroupRow
		if err := rows.Scan(&i.ID, &i.Title); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const validateTilesInSameGroup = `-- name: ValidateTilesInSameGroup :one
WITH tile_count AS (
    SELECT group_id, COUNT(*) as tile_count
    FROM tiles
    WHERE id = ANY($1::bigint[])
    GROUP BY group_id
)
SELECT EXISTS (
    SELECT 1 
    FROM tile_count 
    WHERE tile_count = 4
) AS is_valid
`

func (q *Queries) ValidateTilesInSameGroup(ctx context.Context, dollar_1 []int64) (bool, error) {
	row := q.db.QueryRowContext(ctx, validateTilesInSameGroup, pq.Array(dollar_1))
	var is_valid bool
	err := row.Scan(&is_valid)
	return is_valid, err
}
